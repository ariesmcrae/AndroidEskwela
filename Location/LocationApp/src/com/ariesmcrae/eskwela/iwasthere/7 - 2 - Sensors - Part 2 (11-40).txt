[BLANK_AUDIO]
Hi, I'm Adam Porter, and this is
Programming Mobile Applications for
Android Handheld Systems.
In the example application that we just
looked at,
I tried to hold the device perfectly
straight up.
And if I'd been able to do that, the
accelerometer would ideally have reported
values around x equals 0
meters per second squared, y equals 9.81
meters per
second squared and Z equals 0 meters per
second squared.
But as you saw in the example application,
the accelerometers values fluctuated.
All applications will experience this kind
of thing
due to natural user movement, non flat
surfaces,
electrical noise and so forth.
When creating sensor enabled applications,
developers will often apply
transforms to the raw data to smooth it
out.
2 common kinds of transforms are called
low-pass filters and high-pass filters.
Let's talk about each one of those one at
a time.
Low-pass filters are used to deemphasize
small transient force changes while
emphasizing the long-term constant forces.
You might use a low-pass filter when your
application needs to pay attention to the
constant force
of gravity for example, and you don't
want to
be affected just because your hands shakes
a little.
A real life example of this would be
something like a carpenter's level.
The bubble needs to move based on gravity,
not based on small hand twitches.
In contrast, you use a high-pass filter
when you want to emphasize
the transient force changes, and you
want to deemphasize the constant force
components.
You might use a high-pass filter when
your application should ignore the
constant force
of gravity for example, but should respond
to the specific moves that the user makes.
A real life example of this might be
a percussion instrument like a set or
maracas.
You don't really care about gravity here,
you
care about how the user is shaking the
instrument.
The next application is called sensor
filtered accelerometer.
This application applies both a low pass,
and a high pass filter to the raw
accelerometer values and then, it displays
the filtered values.
Let's run it.
So
here's my device.
Now I'll start up the Sensor Filtered
Accelerometer application.
As you can see, this application displays
9 text views with numbers in them.
These numbers correspond to the x, y, and
z values being read
from the device's accelerometer.
The raw values, after applying a
low pass filter and those raw values after
applying a high pass filter.
If we let the application run for a while,
we'll see that the low pass values begin
to approximate our ideal accelerometer
readings roughly 0
for the x and z axes, and roughly 9.81 for
the y axis.
At the same time, you can see that the
high-pass values all tend toward 0.
If I rotate the device counterclockwise,
you see the high pass x value go positive.
And if I rotate the device clockwise,
you'll
see the high pass x value go negative.
Let's look at the source code for this
application.
Here's the sensor filter accelerometer
application open in the IDE.
Now I'll open the main activity.
And notice again that this class
implements the sensor event listener
interface.
So it can receive callbacks from the
sensor manager.
Now and on create the application gets a
reference to the sensor manager.
Next, it gets a reference to the device's
accelerometer by calling sensor
manager.get default sensor passing in the
type constant that corresponds to the
accelerometer.
In the on resume method, the application
registers this class as a listener
for accelerometer events by calling the
register listener method.
And next, the on pause method unregisters
this class as
a listener for any sensors to which it may
be listening.
Scrolling down, we now come to the on
sensor changed method.
And as before, this method first checks to
make sure that this
event is an accelerometer reading.
And then it checks that a certain amount
of
time has passed since the last reading was
displayed.
If it has, the code records the
accelerometer's x,
y and z values, and then applies the low
pass filter to each of the raw values
after
which the code applies at the high-pass
filter to each
of the raw values.
Let's look at the code for the 2 filters.
Here's the low-pass method, which computes
the low-pass filter.
This method takes 2 parameters: the
current reading and the long term average.
It then computes the filter value, as, as
a kind of weighted average.
In this case,
the filtered value equals 80% of the long
term average plus 20% of the current
reading.
Over time, this calculation moves towards
the
ideal values that we talked about earlier.
Scrolling down, here's the high pass
method
which computes the high pass filtered
values.
And this method also takes 2 parameters -
the current reading, and the long term
average which is actually
computed by the low pass method, that we
just talked about.
This code then subtracts the long-term
average from the current reading and
therefore represents the part of the
reading that is not due to gravity.
This example application is called
SensorCompass
and this application uses the device's
accelerometer and its magnetometer to
orient
a compass arrow towards magnetic north.
So here's my device.
Now I'll start up the sensor compass
application.
As you can see, this application displays
a green
circle with a white arrow.
Right now, this arrow
points towards magnetic north.
However if I begin to
rotate the device, you see that the arrow
continues to point towards
the north which of course is exactly what
a compass should do.
Let's look at the source
code for this application.
Here's the sensor compass application open
in the IDE.
Now I'll open the main activity.
Lets scroll down to the on create method.
As with the other applications, this one
begins by setting up the user interface,
and in particular, it creates a custom
view that holds
the compass arrow and then it adds that
view to the activities main view.
It then
gets a reference to the sensor manager.
After that, it gets a reference to the
device's accelerometer and
it gets a reference to the device's
magnetometer by calling sensor
manager.getdefaultsensor and by passing in
the appropriate type constants.
In the onResume method, the code registers
this class a listener for accelerometer
events and for magnetometer events, by
calling the registerListener method.
The onPause method unregisters this class
as a listener for all sensors.
The onSensor change method processes the
incoming sensor events.
This method first checks whether the event
is an accelerometer or
a magnatometer event and then copies the
appropriate event data.
Next, if there are readings from each of
the 2 sensors, the code called
the sensormanager.getrotationmatrix method
passing in the sensor readings and an
array in which to store the rotation
matrix.
If that method was successful, then the
code called the get sensor manager.
get orientation method passing in the
rotation matrix that we just acquired
from the call to get rotation matrix.
It also passes in
another array called orientation matrix.
When this method returns, orientation
matrix
will hold the information the application
needs
to determine how the device is oriented
with respect to the earth's magnetic
north.
The code then grabs this value from the
orientation matrix and since this value is
measured
in radians, the code then converts the
radian value
to degrees.
After that, the code invalidates the
compass arrow view and then it clears the
arrays that holds the sensor readings.
Let's look at the compass arrow view to
see how it uses the new orientation
information.
Scrolling down to the on draw method, the
code first saves the current canvas
and then it rotates this view on the
canvas by an amount
equal to minus 1 times m rotation
in degrees.
So basically, the idea here is that if the
device is pointing say 90 degrees away
from north, then the compass arrow
must rotate back 90 degrees in order for
the compass arrow to keep pointing north.
That's all for this lesson on sensors.
See you next time when we'll talk about
location and maps.
Thank you.

